Filename: 259-guard-selection.txt
Title: New Guard Selection Behaviour
Author: Isis Lovecruft, George Kadianakis, [Ola Bini]
Created: 2015-10-28
Status: Draft

§1. Overview

  Tor uses entry guards to prevent an attacker who controls some
  fraction of the network from observing a fraction of every user's
  traffic. If users chose their entries and exits uniformly at
  random from the list of servers every time they build a circuit,
  then an adversary who had (k/N) of the network would deanonymize
  F=(k/N)^2 of all circuits... and after a given user had built C
  circuits, the attacker would see them at least once with
  probability 1-(1-F)^C.  With large C, the attacker would get a
  sample of every user's traffic with probability 1.

  To prevent this from happening, Tor clients choose a small number of
  guard nodes (currently 3).  These guard nodes are the only nodes
  that the client will connect to directly.  If they are not
  compromised, the user's paths are not compromised.

  But attacks remain.  Consider an attacker who can run a firewall
  between a target user and the Tor network, and make
  many of the guards they don't control appear to be unreachable.
  Or consider an attacker who can identify a user's guards, and mount
  denial-of-service attacks on them until the user picks a guard
  that the attacker controls.

  In the presence of these attacks, we can't continue to connect to
  the Tor network unconditionally.  Doing so would eventually result
  in the user choosing a hostile node as their guard, and losing
  anonymity.

  This proposal outlines a new entry guard selection algorithm, which
  addresses the following concerns:

    - Heuristics and algorithms for determining how and which guard(s)
      is(/are) chosen should be kept as simple and easy to understand
      as possible.

    - Clients in censored regions or who are behind a fascist firewall
      who connect to the Tor network should not experience any
      significant disadvantage in terms of reachability or usability.

    - Tor should make a best attempt at discovering the most
      appropriate behaviour, with as little user input and
      configuration as possible.


§2. Design

  Alice, an OP attempting to connect to the Tor network, should
  undertake the following steps to determine information about the
  local network and to select (some) appropriate entry guards.  In the
  following scenario, it is assumed that Alice has already obtained a
  recent, valid, and verifiable consensus document.

  The algorithm is divided into three components such that the full
  algorithm is implemented by first invoking START, then repeatedly
  calling NEXT and finally calling END. Several components of NEXT can
  be invoked asynchronously.

  This algorithm keeps track of the unreachability status for guards
  in state private to the algorithm - this is re-initialized every time
  START is called.

  The algorithm expects several arguments to guide its behavior. These
  will be defined in §2.1.

  The goal of this algorithm is to strongly prefer connecting to the
  same guards we have connected to before, while also trying to detect
  conditions such as a network outage or a network environment that
  blocks most ports. The way it does this is by keeping track of how
  many guards we have exposed ourselves to, and if we have connected
  to too many we will fall back to only retrying the ones we have
  already tried.


§2.1. The START algorithm

  In order to start choosing an entry guard, use the START
  algorithm. This takes four arguments that can be used to fine tune
  the workings:

  USED_GUARDS
      This is a list that contains all the guards that have been used
      before by this client. We will prioritize using guards from this
      list in order to minimize our exposure. The list is expected to
      be sorted based on priority, where the first entry will have the
      highest priority.

  EXCLUDE_NODES
      A set of nodes that we should not consider using as a guard.

  N_PRIMARY_GUARDS
      The number of guards we should consider our primary
      guards. These guards will be retried more frequently and will
      take precedence in most situations. By default the primary
      guards will be the first N_PRIMARY_GUARDS guards from USED_GUARDS.

  DIR
      If this argument is set, we should only consider guards that can
      be directory guards. If not set, we will consider all guards.

  The primary work of START is to initialize the different states we
  will need. These are:

  GUARDS
      This is a set of all guards from the consensus, without
      EXCLUDE_NODES and potentially filtered if DIR is set.

  UTOPIC_GUARDS
      This is a set of all guards to use under utopic conditions. This
      set will be initialized to be the same as GUARDS.

  DYSTOPIC_GUARDS
      This is a set of all guards to use under dystopic conditions
      (usually when we are subject to a firewall that restricts the
      ports we can connect to). This set will be initialized to be the
      subset of GUARDS that listen to ports that are allowed by
      dystopic conditions.

  REMAINING_UTOPIC_GUARDS
      This is a running set of the utopic guards we have not yet tried
      to connect to. It should be initialized to be UTOPIC_GUARDS
      without USED_GUARDS.

  REMAINING_DYSTOPIC_GUARDS
      This is a running set of the dystopic guards we have not yet tried
      to connect to. It should be initialized to be DYSTOPIC_GUARDS
      without USED_GUARDS.

  TRIED_GUARDS
      This set keeps track of all utopic guards we have tried connecting
      to. This should be initialized to the empty set.

  TRIED_DYSTOPIC_GUARDS
      This set keeps track of all dystopic guards we have tried connecting
      to. This should be initialized to the empty set.

  STATE
      A variable that keeps track of which state in the state
      machine we are currently in. It should be initialized to
      STATE_PRIMARY_GUARDS.

  PRIMARY_GUARDS
      This list keeps track of our primary guards. These are guards
      that we will prioritize when trying to connect, and will also
      retry more often in case of failure with other guards.
      It should be initialized by calling algorithm
      NEXT_PRIMARY_GUARD repeatedly until PRIMARY_GUARDS contains
      N_PRIMARY_GUARDS elements.


§2.2. The NEXT algorithm

  The NEXT algorithm is composed of several different possibly flows. The
  first one is a simple state machine that can transfer between four
  different states. Every time NEXT is invoked, it will resume at the
  state where it left off previously. In the course of selecting an
  entry guard, a new consensus can arrive. When that happens we need
  to update the data structures used, but nothing else should change.

  Before jumping in to the state machine, we should first check if it
  was at least PRIMARY_GUARDS_RETRY_INTERVAL minutes since we tried
  any of the PRIMARY_GUARDS. If this is the case, and we are not in
  STATE_PRIMARY_GUARDS, we should save the previous state and set the
  state to STATE_PRIMARY_GUARDS.
  [XXX Why doing this before jumping in to state machine rather than on START?
       Unless any state is expected to run for at least 1 second, this time check
       will always have the same output - either at START or before any other
       state's NEXT. And in the case a state is expected to run for 1 second, I
       believe it is a problem, because this is supposed to be faster.]


§2.2.1. The STATE_PRIMARY_GUARDS state

  Return each entry in PRIMARY_GUARDS in turn. For each entry, if it
  was not possible to connect to it, mark the entry as unreachable,
  add it to TRIED_GUARDS and ignore it. If it was possible to connect
  return that entry and be done.
  [XXX defining "was not possible to connect" as "entry is not live" according
       to current definition of "live entry guard" in tor source code, seems
       to improve success rate on the flaky network scenario.
       See: https://github.com/twstrike/tor_guardsim/issues/1#issuecomment-187374942]

  Invoke CHECK_TRIED_THRESHOLD with TRIED_GUARDS as an argument.

  If all entries have been tried, restore the previous state and go
  there. If there is no previous state, transition to STATE_TRY_UTOPIC.


§2.2.2. The STATE_TRY_UTOPIC state

  In order to give guards that have been marked as unreachable a
  chance to come back, add all entries in TRIED_GUARDS that were
  marked as unreachable more than GUARDS_RETRY_TIME minutes ago back
  to REMAINING_UTOPIC_GUARDS.

  Return each entry in USED_GUARDS that is not in PRIMARY_GUARDS in
  turn. For each entry, if it was not possible to connect to it, mark
  the entry as unreachable and add it to TRIED_GUARDS.

  Invoke CHECK_TRIED_THRESHOLD with TRIED_GUARDS as the argument.

  Invoke CHECK_FAILOVER with TRIED_GUARDS, UTOPIC_GUARDS and
  STATE_TRY_DYSTOPIC as arguments.

  Return each entry from REMAINING_UTOPIC_GUARDS using
  NEXT_BY_BANDWIDTH. For each entry, if it was not possible to connect
  to it, remove the entry from REMAINING_UTOPIC_GUARDS, mark it as
  unreachable and add it to TRIED_GUARDS.

  Invoke CHECK_TRIED_THRESHOLD with TRIED_GUARDS as the argument again.

  Invoke CHECK_FAILOVER with TRIED_GUARDS, UTOPIC_GUARDS and
  STATE_TRY_DYSTOPIC as arguments.


§2.2.3. The STATE_TRY_DYSTOPIC state

  In order to give guards that have been marked as unreachable a
  chance to come back, add all entries in TRIED_DYSTOPIC_GUARDS that were
  marked as unreachable more than GUARDS_RETRY_TIME minutes ago back
  to REMAINING_DYSTOPIC_GUARDS.

  Return each dystopic entry in USED_GUARDS that is not in PRIMARY_GUARDS in
  turn. For each entry, if it was not possible to connect to it, mark
  the entry as unreachable and add it to TRIED_DYSTOPIC_GUARDS.

  Invoke CHECK_TRIED_THRESHOLD with TRIED_GUARDS unioned with
  TRIED_DYSTOPIC_GUARDS as the argument.

  Invoke CHECK_FAILOVER with TRIED_DYSTOPIC_GUARDS, DYSTOPIC_GUARDS and
  STATE_ONLY_RETRY as arguments. If the failover check fails, mark all
  guards in PRIMARY_GUARDS, TRIED_GUARDS and TRIED_DYSTOPIC_GUARDS as
  not unreachable.

  Return each entry from REMAINING_DYSTOPIC_GUARDS using
  NEXT_BY_BANDWIDTH. For each entry, if it was not possible to connect
  to it, remove the entry from REMAINING_DYSTOPIC_GUARDS, mark it as
  unreachable and add it to TRIED_DYSTOPIC_GUARDS.

  Invoke CHECK_TRIED_THRESHOLD with TRIED_GUARDS unioned with
  TRIED_DYSTOPIC_GUARDS as the argument.

  Invoke CHECK_FAILOVER with TRIED_DYSTOPIC_GUARDS, DYSTOPIC_GUARDS and
  STATE_ONLY_RETRY as arguments. If the failover check fails, mark all
  guards in PRIMARY_GUARDS, TRIED_GUARDS and TRIED_DYSTOPIC_GUARDS as
  not unreachable.


§2.2.4. The STATE_RETRY_ONLY state

  Return each entry from the union of TRIED_GUARDS and
  TRIED_DYSTOPIC_GUARDS with priority to the ones we haven't
  tried recently. For each entry, if it was not possible to connect
  to it, mark the entry as unreachable again.


§2.2.5. ON_NEW_CONSENSUS

  First, ensure that all guard profiles are updated with information
  about whether they were in the newest consensus or not. If not, the
  guard is considered bad.

  If any PRIMARY_GUARDS have become bad, remove the guard from
  PRIMARY_GUARDS. Then ensure that PRIMARY_GUARDS contain
  N_PRIMARY_GUARDS entries by repeatedly calling NEXT_PRIMARY_GUARD.

  If any guards in USED_GUARDS have switched from being bad to being
  non-bad, add it back in the place it should have been in
  PRIMARY_GUARDS if it had been non-bad when populating
  PRIMARY_GUARDS. If this results in PRIMARY_GUARDS being larger than
  N_PRIMARY_GUARDS, truncate the list to be N_PRIMARY_GUARDS entries
  long.


§2.3. The END algorithm

  The goal of this algorithm is simply to make sure that we keep track
  of successful connections made. This algorithm should be invoked
  with the guard that was used to correctly set up a circuit.

  Once invoked, this algorithm will mark the guard as used, and make
  sure it is in USED_GUARDS.


§2.4. Helper algorithms

  These algorithms are used in the above algorithms, but have been
  separated out here in order to make the flow clearer.

  NEXT_PRIMARY_GUARD
      - Return the first entry from USED_GUARDS that is not in
        PRIMARY_GUARDS, that is in the most recent consensus and,
	that is not marked as unreachable.
      - If USED_GUARDS is empty, use NEXT_BY_BANDWIDTH with
        REMAINING_UTOPIC_GUARDS as the argument.
	[XXX Should the chosen guard be removed from REMAININ_UTOPIC_GUARDS?]
	[XXX Don't we care if is bad or not in most recent consensus?]
  [XXX The spec does not care if this "next" node is known to be unreachable, and
       we pick it anyways. We should not pick unreachable nodes.]
  [XXX The spec does not care if this node from REMAININ_UTOPIC_GUARDS is already in
       PRIMARY_GUARDS, does it? We should.]

  NEXT_BY_BANDWIDTH
      - Takes G as an argument, which should be a set of guards to
        choose from.
      - Return a randomly select element from G, weighted by bandwidth.

  CHECK_TRIED_THRESHOLD
      - Takes G as an argument, which should be a set of guards that
        have been tried.
      - If the number of entries in G that were tried within
        GUARDS_TRY_THRESHOLD_TIME is larger than GUARDS_TRY_THRESHOLD,
        transition to STATE_RETRY_ONLY. We do this in order to ensure
        that we don't expose ourselves to a large number of guards in a
        short amount of time.

  CHECK_FAILOVER
      - Takes three arguments, TG which should be a set of guards that
        have been tried, G which is the set of all guards that could
        have been tried, and S which is a state to transfer to.
      - If the number of entries in TG is larger than a
        GUARDS_FAILOVER_THRESHOLD proportion of G, transition to
        state S.

§3. Consensus Parameters, & Configurable Variables

  This proposal introduces several new parameters that ideally should
  be set in the consensus but that should also be possible to
  set or override in the client configuration file. Some of these have
  proposed values, but for others more simulation and trial needs to
  happen.

  PRIMARY_GUARDS_RETRY_INTERVAL
      In order to make it more likely we connect to a primary guard,
      we would like to retry the primary guards more often than other
      types of guards. This parameter controls how many minutes should
      pass before we consider retrying primary guards again. The
      proposed value is 3.

  GUARDS_TRY_THRESHOLD_TIME
      We want to make sure we are not connecting to too many guards in
      too short amount of time. This parameter controls how many
      minutes this window of time should be. Proposed value is 120.

  GUARDS_TRY_THRESHOLD
      This parameter controls the maximum fraction of guards we should
      try connecting to within GUARDS_TRY_THRESHOLD_TIME. This is a
      fraction that should be taken against the total number of guards
      in the consensus. If we assume the current consensus contains
      1900 guards, a value of 0.03 gives us a maximum of 57 guards to
      try connecting to. Proposed value is 0.03.

  GUARDS_RETRY_TIME
      In the normal course of selecting guards, we want to continue
      retrying unreachable guards in case they have become
      reachable. This parameter controls the minimum amount of minutes
      before we should start consider guards for connecting
      again. Proposed value is 20.

  GUARDS_FAILOVER_THRESHOLD
      In order to allow us to recognize dystopic situations or a
      completely unreachable network, we would like to avoid
      connecting to too many guards before switching modes. This
      parameter, expressed as a fraction, determines the number of
      guards we should try connecting to before switching from utopic
      to dystopic mode, or from dystopic to offline mode. If we assume
      there are 1900 utopic guards and of them there are 500 dystopic
      guards, a setting of 0.02 means we will try to connect to 38
      utopic guards before switching to dystopic mode. At that point
      we will try 10 more dystopic guards before we conclude that the
      network is down. Proposed value is 0.02.


[XXX: should we remember we are potentially dystopic, and lower the
utopic threshold in that case next time we run the algorithm?]

[XXX: what risks are we subjected to by not remembering previous choices? Can this lead to cycling again?]

§4.  Security properties and behavior under various conditions

  Under normal conditions, this algorithm will allow us to quickly
  connect and use guards we have used before with high likelihood of
  working. Assuming the first primary guard is reachable and in the
  consensus, this algorithm will deterministically always return that
  guard.

  Under dystopic conditions (when a firewall is in place that blocks
  all ports except for potentially port 80 and 443), this algorithm
  will try to connect to 2% of all guards before switching modes to try
  dystopic guards. Currently, that means trying to connect to circa 40
  guards before getting a successful connection. If we assume a
  connection try will take maximum 10 seconds, that means it will take
  up to 6 minutes to get a working connection.

  When the network is completely down, we will try to connect to 2% of
  all guards plus 2% of all dystopic guards before realizing we are
  down. This means circa 50 guards tried.

  In terms of exposure, we will connect to a maximum of 2% of all
  guards plus 2% of all dystopic guards, or 3% of all guards,
  whichever is lower. If N is the number of guards, and k is the
  number of guards an attacker controls, that means an attacker would
  have a probability of 1-(1-(k/N)^2)^(N * 0.03) to have one of their
  guards selected before we fall back. In real terms, this means an
  attacker would need to control over 10% of all guards in order to
  have a larger than 50% chance of controlling a guard for any given client.


§A. Appendix: An example usage

  In order to clarify how this algorithm is supposed to be used, this
  pseudo code illustrates the building of a circuit:

    OPEN_CIRCUIT:
      context = ALGO_CHOOSE_ENTRY_GUARD_START(used_guards, [], 3, false)

      while True:
        entryGuard = ALGO_CHOOSE_ENTRY_GUARD_NEXT(context)
        circuit = buildCircuitWith(entryGuard)
        if circuit:
          ALGO_CHOOSE_ENTRY_GUARD_END(context, entryGuard)
          return circuit

-*- coding: utf-8 -*-
